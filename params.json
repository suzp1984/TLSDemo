{"name":"TLSDemo","tagline":"A demo illustrate how to implement https client request in Android, it also meaningful in all JDK environment.","body":"# TLS Demo\r\nA sample to show up how to use https client in Android.\r\n\r\n\r\n# Java Keytool\r\n\r\nJava keystore is like a database which store certificates\r\nand private keys and protect them by a password maybe. There\r\nare at least three [formats](http://docs.oracle.com/javase/6/docs/technotes/guides/security/StandardNames.html#KeyStore) of that, JKS, PKCS12, JCEKS, and\r\nmany more.\r\n\r\nBut in this tutorial, I only consider two formats of that\r\nJKS which is the Java's default format and BKS which is the\r\nAndroid's default format.\r\n\r\nHow to write the certificate to the BKS style KeyStore?\r\nFirst step was to prepare your certificate at least, the PEM\r\nformat and DER format is ok. Then to download\r\n[bcprov-jdk16-146.jar](http://www.bouncycastle.org/fr/download/bcprov-jdk16-146.jar). after that use following command to\r\nimport an X590 certificate into the keystore.\r\n\r\n```sh\r\n  keytool -importcert -v -trustcacerts -file \"my_server_cert.der\" -alias key_alias -keystore \"my.bks\" -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath \"bcprov-jdk16-146.jar\" -storetype BKS\r\n```\r\n\r\nImport an PEM X509 certificate into JKS keystore:\r\n\r\n```sh\r\n  keytool -importcert -v -trustcacerts -file \"cas.pem\" -alias cas_alias -keystore \"cas.jks\" -storetype JKS\r\n```\r\n\r\nThe default export format of keytool is der format.\r\n\r\n```sh\r\n  keytool -exportcert -alias cas_alias -keystore \"cas.jks\" > cas.der\r\n  \r\n```\r\n\r\n# Certificate formats\r\n\r\nThe certificate which I mentioned here are all reference to \r\nX509 format, which is not just the most wildly used, but also\r\nthe standard in the PKI industry. The evidence is that there\r\nare Certificate interface in the JDK, but with just only one\r\nchild, X509Certificate class.\r\n\r\nNow, go back to the point, there are two X509 Certificate formats here,\r\nPEM and CER, they are equivalent same things. PEM is base64 encoded \r\nformat, CER is the binary format.\r\n\r\nUsing the following cmds to download and convert between each other.\r\n\r\n```sh\r\n  #download pem certificate by guntls\r\n  gnutls-cli --print-cert www.youwebsite.com | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'\r\n  \r\n  #download pem certificate by openssl\r\n  openssl s_client -connect ${HOST}:${PORT} </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'\r\n  \r\n  # convert DER binary format certificate to PEM base64 encoded format\r\n  openssl x509 -inform der -in cas.der -outform pem -out cas.pem\r\n  \r\n  # convert PEM base64 encoded format certificate to DER binary format\r\n  openssl x509 -inform pem -in cas.pem -outform der -out cas.der\r\n  \r\n```\r\n\r\n# Use Https in Android Client\r\n\r\nBefore going that, you need to figure out how many http clients in Android.\r\nBasically, there are only two http clients available in Android, HttpUrlConnection\r\nand AndroidHttpClient, which two are provided by the system. While HttpUrlConnection\r\nis the barely the only one left now, because AndroidHttpClient and its sibling, \r\nDefaultHttpClient and its parent HttpClient are all deprecated in Android 2.3. So\r\nchoose HttpUrlConnection if you wanna wrote any http client code.\r\n\r\nAnd the most of the 3rd party Http Clients are developed above them, Volley, and what ever,\r\nbut Square's OkHttp, which implements its own http stack.\r\n\r\n# Java SSLContext\r\n\r\nI think to use SSL programming in java is to understand SSLContext and its \r\nrelated classes KeyManager, TrustManager, KeyManagerFactory, TrustManagerFactory,\r\nand SSLSocketFactory.\r\n\r\nHere is just a piece of code:\r\n\r\n```java\r\n\r\n        KeyStore keyStore = null;\r\n        try {\r\n            keyStore = KeyStore.getInstance(\"BKS\");\r\n            keyStore.load(in, passwd.toCharArray());\r\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\r\n            tmf.init(keyStore);\r\n\r\n            TrustManager[] tms = tmf.getTrustManagers();\r\n\r\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\r\n            sslContext.init(null, tms, null);\r\n            SSLSocketFactory ssf = sslContext.getSocketFactory();\r\n            \r\n        } catch (KeyStoreException e) {\r\n            e.printStackTrace();\r\n        } catch (CertificateException e) {\r\n            e.printStackTrace();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n\r\n```\r\n\r\nWhile that's not enough, that's why I wrote following demo [TLSDemo](https://github.com/suzp1984/TLSDemo).\r\n\r\n# Two-way SSL verfication\r\n\r\nSSL support server-side verification, just the reverse of the former ones, at this time the\r\ncertificates are stored in the client side, and also a private key. So how to configure\r\nthe client side to support those feature.\r\n\r\nThe key point is to give the Keyanager array to the SSLContext.init method.\r\n\r\n```java\r\n    sslContext.init(new KeyManager[]{km}, tms, null);\r\n```\r\n\r\nfollowing methods is example of generate a KeyManager from the client certificate and\r\nits related private key, and the factoray class, CustomKeyManagerFactory is the\r\nwrapper class that you can leverage.\r\n\r\nOh, in android platform, it only support pkcs8 format private key.\r\n\r\n```java\r\n    public SSLSocketFactory getSSLSocketFactoryWithKeyManagerFromPem(String clientPem,\r\n            String privateKey, String servrePem) {\r\n        ArrayList<TrustManager> tmsList = new ArrayList<>();\r\n\r\n        TrustManager tm = CustomTrustManagerFactory.getTrustManagerFromPEM(servrePem);\r\n\r\n        tmsList.add(tm);\r\n        TrustManager[] tms = tmsList.toArray(new TrustManager[tmsList.size()]);\r\n\r\n        KeyManager km = CustomKeyManagerFactory.getKeyManagerFromFile(clientPem, privateKey);\r\n        try {\r\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\r\n            sslContext.init(new KeyManager[]{km}, tms, null);\r\n            return sslContext.getSocketFactory();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        } catch (KeyManagementException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return null;\r\n    }\r\n```\r\n\r\n# TLSDemo\r\n\r\nI wrote this demo here [TLSDemo](https://github.com/suzp1984/TLSDemo) to illustrate how to use SSL client in Android.\r\nIt illustrates following puzzles:\r\n\r\n- How to import certificates in PEM format.\r\n- How to import certificates in BKS type Keystore.\r\n- How to connect https sites in HttpUrlConnection.\r\n\r\nThere are still some faults in this demo that is the HttpClient https \r\nconnection is not implemented actually, because of the already deprecated \r\napi was so incompatible, for example, HttpClient is the apache's http\r\nclient interface, so its SSLSocketFactory is not compatible with the\r\njavax.net.SSLSocketFactory.\r\n\r\nBut except the unfinished HttpClient implementation, [TLSDemo](https://github.com/suzp1984/TLSDemo) is still a \r\ngood reference of how to use https in UrlConnection, and how SSLContext \r\nworks?\r\n\r\n\r\n# reference resources\r\n- [http://developer.android.com/training/articles/security-ssl.html](http://developer.android.com/training/articles/security-ssl.html)\r\n- [http://ogrelab.ikratko.com/using-android-volley-with-self-signed-certificate/](http://ogrelab.ikratko.com/using-android-volley-with-self-signed-certificate/)\r\n- [http://stackoverflow.com/questions/2138940/import-pem-into-java-key-store](http://stackoverflow.com/questions/2138940/import-pem-into-java-key-store)\r\n- [http://stackoverflow.com/questions/3685548/java-keytool-easy-way-to-add-server-cert-from-url-port](http://stackoverflow.com/questions/3685548/java-keytool-easy-way-to-add-server-cert-from-url-port)\r\n\r\n","google":"UA-20256105-3","note":"Don't delete this file! It's used internally to help with page regeneration."}